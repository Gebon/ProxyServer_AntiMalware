using System;
using System.Collections.Generic;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace HTTPProxyServer
{
    public sealed class ProxyServer
    {
        private static readonly ProxyServer InternalServer = new ProxyServer();

        private static readonly int BUFFER_SIZE = 8192;
        private static readonly char[] SemiSplit = { ';' };
        private static readonly string[] ColonSpaceSplit = { ": " };
        private static readonly char[] SpaceSplit = { ' ' };
        private static readonly Regex CookieSplitRegEx = new Regex(@",(?! )");
        private static readonly object OutputLockObj = new object();


        private readonly TcpListener listener;
        private Thread listenerThread;

        public IPAddress ListeningIPInterface
        {
            get
            {
                var addr = IPAddress.Loopback;
                if (ConfigurationManager.AppSettings["ListeningIPInterface"] != null)
                    IPAddress.TryParse(ConfigurationManager.AppSettings["ListeningIPInterface"], out addr);

                return addr;
            }
        }

        public int ListeningPort
        {
            get
            {
                var port = 8081;
                if (ConfigurationManager.AppSettings["ListeningPort"] != null)
                    int.TryParse(ConfigurationManager.AppSettings["ListeningPort"], out port);

                return port;
            }
        }

        private ProxyServer()
        {
            listener = new TcpListener(ListeningIPInterface, ListeningPort);
            ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
        }

        public bool DumpHeaders { get; set; }
        public bool DumpPostData { get; set; }
        public bool DumpResponseData { get; set; }

        public static ProxyServer Server
        {
            get { return InternalServer; }
        }

        public void Start()
        {
            listener.Start();
            listenerThread = new Thread(() => Listen(listener));

            listenerThread.Start();
        }

        public void Stop()
        {
            listener.Stop();

            //wait for server to finish processing current connections...

            listenerThread.Abort();
            listenerThread.Join();
            listenerThread.Join();
        }

        private static void Listen(TcpListener listener)
        {
            try
            {
                while (true)
                {
                    var client = listener.AcceptTcpClient();
                    Task.Factory.StartNew(() => ProcessClient(client)).Wait();
                }
            }
            catch (ThreadAbortException) { }
            catch (SocketException) { }
            catch (AggregateException) { }
        }


        private static void ProcessClient(TcpClient client)
        {
            try
            {
                DoHttpProcessing(client);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            finally
            {
                client.Close();
            }
        }

        private static void DoHttpProcessing(TcpClient client)
        {
            using (Stream clientStream = client.GetStream())
            using (var outStream = clientStream)
            using (var clientStreamReader = new StreamReader(clientStream))
            {
                if (Server.DumpHeaders || Server.DumpPostData || Server.DumpResponseData)
                {
                    //make sure that things print out in order - NOTE: this is bad for performance
                    Monitor.TryEnter(OutputLockObj, TimeSpan.FromMilliseconds(-1.0));
                }

                try
                {
                    //read the first line HTTP command
                    var httpCmd = clientStreamReader.ReadLine();
                    if (string.IsNullOrEmpty(httpCmd))
                    {
                        clientStreamReader.Close();
                        clientStream.Close();
                        return;
                    }
                    //break up the line into three components
                    var splitBuffer = httpCmd.Split(SpaceSplit, 3);

                    var method = splitBuffer[0];
                    var remoteUri = splitBuffer[1];
                    var version = new Version(1, 0);

                    HttpWebRequest webReq;
                    HttpWebResponse response = null;

                    //construct the web request that we are going to issue on behalf of the client.
                    webReq = WebRequest.Create(remoteUri) as HttpWebRequest;
                    Debug.Assert(webReq != null, "webReq != null");
                    webReq.Method = method;
                    webReq.ProtocolVersion = version;

                    //read the request headers from the client and copy them to our request
                    var contentLen = ReadRequestHeaders(clientStreamReader, webReq);

                    webReq.Proxy = null;
                    webReq.KeepAlive = false;
                    webReq.AllowAutoRedirect = false;
                    webReq.AutomaticDecompression = DecompressionMethods.None;


                    if (Server.DumpHeaders)
                    {
                        Console.WriteLine(string.Format("{0} {1} HTTP/{2}", webReq.Method, webReq.RequestUri.AbsoluteUri,
                            webReq.ProtocolVersion));
                        DumpHeaderCollectionToConsole(webReq.Headers);
                    }

                    webReq.Timeout = 1000;

                    try
                    {
                        response = (HttpWebResponse)webReq.GetResponse();
                    }
                    catch (WebException webEx)
                    {
                        response = webEx.Response as HttpWebResponse;
                    }
                    if (response == null) return;
                    using (response)
                    using (var myResponseWriter = new StreamWriter(outStream))
                    using (var responseStream = response.GetResponseStream())
                    {
                        var responseHeaders = ProcessResponse(response);
                        try
                        {
                            //send the response status and response headers
                            WriteResponseStatus(response.StatusCode, response.StatusDescription, myResponseWriter);
                            WriteResponseHeaders(myResponseWriter, responseHeaders);

                            byte[] buffer;
                            buffer = response.ContentLength > 0
                                ? new byte[response.ContentLength]
                                : new byte[BUFFER_SIZE];

                            int bytesRead;
                            if (remoteUri == "http://www.e1.ru/")
                            {
                                var body = new StringBuilder();
                                while ((bytesRead = responseStream.Read(buffer, 0, buffer.Length)) > 0)
                                {
                                    body.Append(Encoding.Default.GetString(buffer, 0, bytesRead));
                                }
                                var modifiedBody = Regex.Replace(body.ToString(),
                                    @"<div id='.*?' class='ngs-adv-async'.*?</div><script.*?</script>", "");
                                new StreamWriter(outStream, Encoding.Default).Write(modifiedBody);
                            }
                            else
                                while ((bytesRead = responseStream.Read(buffer, 0, buffer.Length)) > 0)
                                {
                                    outStream.Write(buffer, 0, bytesRead);
                                    if (Server.DumpResponseData)
                                        Console.Write(Encoding.UTF8.GetString(buffer, 0, bytesRead));
                                }
                            if (Server.DumpResponseData)
                            {
                                Console.WriteLine();
                                Console.WriteLine();
                            }

                            responseStream.Close();
                            outStream.Flush();
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine(ex.Message);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
                finally
                {
                    if (Server.DumpHeaders || Server.DumpPostData || Server.DumpResponseData)
                    {
                        Monitor.Exit(OutputLockObj);
                    }
                }
            }
        }

        private static List<Tuple<string, string>> ProcessResponse(HttpWebResponse response)
        {
            string value = null;
            string header = null;
            var returnHeaders = new List<Tuple<string, string>>();
            foreach (string s in response.Headers.Keys)
            {
                if (s.ToLower() == "set-cookie")
                {
                    header = s;
                    value = response.Headers[s];
                }
                else
                    returnHeaders.Add(new Tuple<string, string>(s, response.Headers[s]));
            }

            if (!string.IsNullOrWhiteSpace(value))
            {
                response.Headers.Remove(header);
                var cookies = CookieSplitRegEx.Split(value);
                foreach (var cookie in cookies)
                    returnHeaders.Add(new Tuple<string, string>("Set-Cookie", cookie));

            }
            returnHeaders.Add(new Tuple<string, string>("X-Proxied-By", "BigBear Proxy"));
            return returnHeaders;
        }

        private static void WriteResponseStatus(HttpStatusCode code, string description, StreamWriter myResponseWriter)
        {
            var s = string.Format("HTTP/1.0 {0} {1}", (int)code, description);
            myResponseWriter.WriteLine(s);
            if (Server.DumpHeaders)
                Console.WriteLine(s);
        }

        private static void WriteResponseHeaders(StreamWriter myResponseWriter, List<Tuple<string, string>> headers)
        {
            if (headers != null)
            {
                foreach (var header in headers)
                    myResponseWriter.WriteLine(string.Format("{0}: {1}", header.Item1, header.Item2));
            }
            myResponseWriter.WriteLine();
            myResponseWriter.Flush();

            if (Server.DumpHeaders)
                DumpHeaderCollectionToConsole(headers);
        }

        private static void DumpHeaderCollectionToConsole(WebHeaderCollection headers)
        {
            foreach (var s in headers.AllKeys)
                Console.WriteLine(string.Format("{0}: {1}", s, headers[s]));
            Console.WriteLine();
        }

        private static void DumpHeaderCollectionToConsole(List<Tuple<string, string>> headers)
        {
            foreach (var header in headers)
                Console.WriteLine(string.Format("{0}: {1}", header.Item1, header.Item2));
            Console.WriteLine();
        }

        private static int ReadRequestHeaders(StreamReader sr, HttpWebRequest webReq)
        {
            string httpCmd;
            var contentLen = 0;
            do
            {
                httpCmd = sr.ReadLine();
                if (string.IsNullOrEmpty(httpCmd))
                    return contentLen;
                var header = httpCmd.Split(ColonSpaceSplit, 2, StringSplitOptions.None);
                switch (header[0].ToLower())
                {
                    case "host":
                        webReq.Host = header[1];
                        break;
                    case "user-agent":
                        webReq.UserAgent = header[1];
                        break;
                    case "accept":
                        webReq.Accept = header[1];
                        break;
                    case "referer":
                        webReq.Referer = header[1];
                        break;
                    case "cookie":
                        webReq.Headers["Cookie"] = header[1];
                        break;
                    case "proxy-connection":
                    case "connection":
                    case "keep-alive":
                        //ignore these
                        break;
                    case "content-length":
                        int.TryParse(header[1], out contentLen);
                        break;
                    case "content-type":
                        webReq.ContentType = header[1];
                        break;
                    case "if-modified-since":
                        var sb = header[1].Trim().Split(SemiSplit);
                        DateTime d;
                        if (DateTime.TryParse(sb[0], out d))
                            webReq.IfModifiedSince = d;
                        break;
                    default:
                        try
                        {
                            webReq.Headers.Add(header[0], header[1]);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine("Could not add header {0}.  Exception message:{1}", header[0], ex.Message);
                        }
                        break;
                }
            } while (!string.IsNullOrWhiteSpace(httpCmd));
            return contentLen;
        }
    }
}
